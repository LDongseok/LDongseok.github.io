<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8"/>
  <title>Filled Polygon</title>
  <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
  <style>
    body {
      font-family: Arial, sans-serif;
      background-color: black;
      color: lightblue;
      margin: 0; padding: 0; text-align: center;
    }
    .container {
      width: 80%;
      margin: auto;
      padding: 20px;
    }
    #plot {
      width: 600px;
      height: 400px;
      margin: auto;
      background-color: #222;
    }
    .description {
      text-align: left;
      background-color: #333;
      padding: 10px;
      border-radius: 5px;
      display: inline-block;
    }
    #feedback {
      margin-top: 15px;
      font-size: 1.1em;
      color: cyan;
      text-align: left;
      width: 600px;
      margin: 15px auto;
      background-color: #222;
      padding: 10px;
      border-radius: 5px;
    }
    button {
      background: red;
      color: white;
      border: none;
      padding: 10px 20px;
      font-size: 1.2em;
      cursor: pointer;
      border-radius: 5px;
      margin-top: 20px;
    }
  </style>
</head>
<body>
<div class="container">
  <h1>Domain Creator (Filled Polygon)</h1>
  <div class="description">
    <p>
      This version uses raw mouse events for exact (x,y) coordinates, and then draws 
      a single “filled” polygon with <code>fill: "toself"</code>.
    </p>
    <p>
      It does <strong>not</strong> generate a triangular mesh inside; it simply 
      fills the polygon with a solid color.
    </p>
  </div>
  <div id="plot"></div>
  <div id="feedback">No points clicked yet.</div>
  <button onclick="clearPolygon()">Clear Polygon</button>
</div>

<script>
  let domainPoints = [];  // Store clicked points in order
  let gd;                 // The plot DOM element

  // 1) Create an empty scatter trace that we'll update as user clicks
  let polygonTrace = {
    x: [],
    y: [],
    mode: 'lines+markers',
    fill: 'toself',             // fill the polygon
    fillcolor: 'rgba(255, 0, 0, 0.2)',  // translucent red
    line: { color: 'red' },
    marker: { color: 'cyan', size: 8 },
    name: "Polygon"
  };

  // 2) Layout with default range [0,1] for x and y
  let layout = {
    title: "Click anywhere to define a polygon",
    xaxis: { range: [0, 1], title: "x" },
    yaxis: { range: [0, 1], title: "y" }
  };

  // 3) Initialize the plot
  Plotly.newPlot("plot", [polygonTrace], layout).then(function(plotDiv) {
    gd = plotDiv;
    // Listen for raw mouse events
    gd.addEventListener("mousedown", onMouseDown);
  });

  function onMouseDown(evt) {
    let rect = gd.getBoundingClientRect();
    let xPixel = evt.clientX - rect.left;
    let yPixel = evt.clientY - rect.top;

    let xAxis = gd._fullLayout.xaxis;
    let yAxis = gd._fullLayout.yaxis;

    let xMinPix = xAxis._offset;
    let xMaxPix = xAxis._offset + xAxis._length;
    let yMinPix = yAxis._offset + yAxis._length;
    let yMaxPix = yAxis._offset;

    let xDataMin = xAxis.range[0];
    let xDataMax = xAxis.range[1];
    let yDataMin = yAxis.range[0];
    let yDataMax = yAxis.range[1];

    // Convert pixel -> data coords
    let xData = xDataMin + (xPixel - xMinPix) / (xMaxPix - xMinPix) * (xDataMax - xDataMin);
    let yData = yDataMin + (yMinPix - yPixel) / (yMinPix - yMaxPix) * (yDataMax - yDataMin);

    // Add new point to domainPoints
    domainPoints.push([xData, yData]);

    // Update polygonTrace with the new list of points
    let xs = domainPoints.map(pt => pt[0]);
    let ys = domainPoints.map(pt => pt[1]);

    // For fill: "toself" to close properly, we typically repeat the first point at the end
    // Or rely on "fill: 'toself'" automatically closing. Let's rely on it automatically.
    Plotly.update("plot", {
      x: [xs],
      y: [ys]
    }, {}, [0]);

    updateFeedback();
  }

  function updateFeedback() {
    if (domainPoints.length === 0) {
      document.getElementById("feedback").innerText = "No points clicked yet.";
      return;
    }
    let msg = "You have clicked " + domainPoints.length + " point(s):<br>";
    domainPoints.forEach((pt, i) => {
      msg += `Point ${i+1}: (${pt[0].toFixed(3)}, ${pt[1].toFixed(3)})<br>`;
    });
    document.getElementById("feedback").innerHTML = msg;
  }

  // Clear the polygon
  function clearPolygon() {
    domainPoints = [];
    Plotly.update("plot", { x: [[]], y: [[]] }, {}, [0]);
    updateFeedback();
  }
</script>
</body>
</html>





